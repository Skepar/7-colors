\documentclass{article}
\usepackage{courier}
\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}

\title{Les 7 merveilles du monde des 7 couleurs}
\date{15 Octobre 2019}
\author{Antoine Geimer et Pierre Bourse}
\begin{document}
\maketitle

\section{Introduction}
    \quad Le jeu des 7 couleurs (aussi connu sous le nom \enquote{The 7 colors}) est un jeu développé par Gamos Ltd. et publié par Infogrames Europe SA, dans lequel deux joueurs s'affrontent dans le but d'agrandir sa zone, afin de dépasser celle de l'autre joueur en superficie. La zone de jeu est divisée en plusieurs en cases de 7 différentes couleurs. Lorsque le joueur choisit une couleur, les séquences de cases de cette couleur adjacentes à sa zone la rejoignent. On souhaite ici réimplémenter ce jeu en C, et le doter de différentes IAs que le joueur pourra affronter. On cherche également à expérimenter avec ces IAs en les faisant s'affronter entre elles, afin de juger de leurs performances. Les couleurs sont représentées par des lettres, allant de A à G.
\section{Questions}
\subsection{Question 1}
    Nous avons tout d'abord changé l'implémentation proposée pour travailler avec un tableau en deux dimensions plutôt qu'un tableau en une seule dimension. Cela nous paraissait plus logique sémantiquement, car plus proche de la grille représentée. Le tableau doit être rempli aléatoirement avec les lettres, nous avons donc créé la fonction \texttt{init\_board} dans ce but, qui alloue le tableau et renvoie un pointeur vers son premier élément. Pour éviter que le tableau soit désalloué à la fin de cette fonction, nous utilisons la fonction \texttt{malloc} (couplée avec une fonction \texttt{free\_board}, appelée en fin de jeu).
    Les lettres choisies ont la particularité d'avoir un code ASCII entre 65 et 71. Ainsi, il suffit pour générer un caractère aléatoire de génerer un entier entre 65 et 71 pour chaque case du tableau. Enfin, il faut remplacer les cases en haut à droite et en bas à gauche par le symbole du joueur correspondant.
\subsection{Question 2}
    Pour cela, nous avons suivi exactement la méthode indiquée dans le sujet du projet, à travers la fonction \texttt{world\_update}. Pour vérifier qu'elle fait ce qu'on veut, il faut créer une fonction capable d'afficher le monde, puis afficher dans le terminal dans l'ordre le monde généré aléatoirement, le monde une fois \texttt{world\_update} appelée pour une certaine couleur et un certain joueur, puis après que la même fonction soit appelée pour une autre couleur et l'autre joueur. 
    Si n est la longueur du côté du monde, le nombre de parcours dans le pire des cas est borné par $n^2$ car on ne peut faire au maximum qu'un parcours par case modifiée. De plus, il existe une configuration dans laquelle le nombre de parcours est en $O(n^2)$ : lorsque le monde est une alternance de lignes de A et de lignes de B, avec un A seulement sur chaque ligne de B, à la manière d'un serpentin. Le nombre de parcours dans le pire des cas est alors un $O(n^2)$.
\subsection{Question 3}
    Nous avons remplacé \texttt{world\_update} par la fonction \texttt{better\_world\_update}, qui effectue moins de parcours. Celle-ci utilise un tableau 2D \texttt{explored} et une fonction annexe \texttt{update} qui va faire un parcours du monde en commençant par la case de départ du joueur actuel. Le parcours va se faire à la fois sur toutes les cases du joueur et toutes les cases à modifier. Le tableau \texttt{explored} nous permet de garder une trace des cases qui ont déja été explorées, pour ne pas les explorer une deuxième fois. Cette fonction a été implémentée après les fonctions nous permettant de jouer . Ainsi, il nous a suffit de jouer pour vérifier en le bon fonctionnement.
\subsection{Question 4}
    Pour faire jouer deux humains entre eux, nous avons d'abord créé une structure \texttt{Game} qui contient toutes les informations nécessaires au déroulement d'une partie. Cela nous permet également d'éliminer tout recours à des variables globales, et simplifie certains appels de fonctions. Nous générons alors au début d'une partie un pointeur vers un \texttt{Game} que nous passerons en argument à toutes les fonctions principales. La fonction \texttt{play\_turn}, qui gère le déroulement d'un tour, est alors appelée (pour l'instant) à l'infini, en alternant de joueur à chaque tour.
    Dans cette question, le jeu a un intérêt assez limité : il ne se termine jamais. De plus, il n'existe pas de mode 1 joueur avec une intelligence artificielle, et le fait que les couleurs soient remplacées par des caractères rend le jeu compliqué à lire et à comprendre. On a également plus tard ajouté des garde-fous afin d'éviter que le joueur entre une couleur inexistante ou encore le symbole de son adversaire.
\subsection{Question 5}
    On peut déclarer un joueur victorieux s'il possède plus de 50\% du monde, le second joueur ne pouvant alors jamais le dépasser. Il suffit donc de garder en mémoire le taux d'occupation du monde pour chaque joueur, et de le modifier à chaque tour (avec affichage éventuellement). Un joueur est déclaré vainqueur dès que son taux d'occupation dépasse les 50\% du monde.
\subsection{Question 6}
    Nous avons créé un fichier annexe regroupant les différentes stratégies possibles pour l'IA. De plus, un membre a été ajouté dans le \texttt{Game} afin de modéliser le mode de jeu. Celui-ci est pour l'instant utilisé pour savoir si on joue en mode \enquote{joueur contre joueur} ou \enquote{IA contre joueur}. Dans le second cas, la stratégie de l'IA est simple : il suffit de générer un entier aléatoire entre 65 et 71 correspondant au code ASCII d'un caractère, et de modifier le monde, comme si le joueur adverse avait joué ce caractère.
\subsection{Question 7}
    On procède de la même façon que pour l'IA complétement aléatoire, mais le caractère choisi par l'IA sera renvoyé par la fonction \texttt{semi\_random\_strategy} qui prend un pointeur vers le \texttt{Game} en argument. Le programme initialise d'abord un tableau de 7 fois 0 et va parcourir le monde 1 fois en regardant pour chaque case si elle est adjacente au territoire du joueur actuel. Si elle l'est, on passe la case du tableau correspondant au caractère de la case à 1 (A correspond à la case d'indice 0, B à celle d'indice 1, etc.). Ainsi, le tableau contient un 1 dans la case i si et seulement si le caractère correspondant est adjacent au territoire du joueur. Il suffit alors de compter le nombre n de 1, de choisir un nombre aléatoire r entre 1 et n et de prendre le caractère correspondant à la $r^e$ occurence d'un 1 dans le tableau.
\subsection{Question 8}
    Pour notre \texttt{greedy\_strategy}, nous regardons, pour chaque couleur choisie par le joueur en cours, le score que le joueur gagnerait s'il choisissait cette couleur. Pour cela, nous faisons un parcours du monde par couleur. Ce parcours se fait avec la fonction \texttt{explore}. Ce parcours démarre sur la case de départ du joueur dont c'est le tour, et va récursivement s'appeler sur toutes les cases adjacentes si elles sont de la couleur du joueur ou de la couleur testée, en ajoutant 1 au score potentiel si la case visitée est de la couleur testée. Pour que ce parcours se termine, un pointeur vers un tableau \texttt{explored} est utilisé. Celui-ci est initialisé comme ne contenant que des cases \enquote{\texttt{UNEXPLORED}}, symbolise le monde et est mis à jour à chaque appel de \texttt{explore} pour qu'on n'explore pas 2 fois la même case. Une fois que les 7 parcours sont terminés, \texttt{greedy\_strategy} renvoie le caractère qui maximise le score gagné lors du parcours par \texttt{explore}.
\subsection{Question 9}
    Pour faire s'affronter deux IA entre elles, nous avons ajouté un mode de jeu \enquote{IA contre IA}. Pour que le combat soit vraiment équitable, il faut que le terrain soit symétrique. Une symétrie centrale ou une symétrie axiale par rapport à la diagonale qui va du haut à gauche au bas à droite créent un terrain équitable car chaque joueur a accès exactement aux mêmes caractères s'ils jouent le même coup. Nous avons opté pour la symétrie axiale, que nous avons donc implémentée dans la fonction \texttt{init\_board}.
\subsection{Question 10}
    Pour faire s'affronter deux IA entre elles sur plusieurs parties, nous avons implémenté une fonction \texttt{run\_n\_times} qui permet de simuler n parties sans afficher le monde à chaque étape, et d'afficher le nombre de parties gagnées par chacun des joueurs. Par souci d'équité, nous faisons en sorte que le premier joueur alterne entre les deux qui s'affrontent. Le joueur artificiel glouton a beaucoup plus de victoires. Il en a parfois 99 mais très souvent 100 sur 100 parties.
\subsection{Question 11}
    Pour le joueur hégémonique, nous avons réutilisé la fonction \texttt{explore} que nous avons modifiée en lui ajoutant un argument \texttt{is\_perimeter\_based}. Si celui-ci ne vaut pas 0, alors le parcours ne se fera pas de la même façon, et comptera le nombre de cases adjacentes à la zone du joueur (le périmètre), s'il joue une certaine couleur. Ainsi, l'algorithme définissant la stratégie de l'IA hégémonique consiste en un parcours avec explored pour chaque couleur , dans le but de sélectionner la couleur qui maximisera le périmètre du joueur après qu'il ait joué cette couleur. Avec cet algorithme, nous avions un problème : après un moment, toutes les couleurs qui faisaient gagner des cases au joueur hégémonique lui faisaient perdre en périmètre. Il choisissait donc de jouer une couleur qui ne lui faisait pas gagner de cases, et cela à l'infini. Ainsi, nous avons réglé ce problème en réutilisant les fonctions utilisées par \texttt{semi\_random\_strategy} afin de ne faire jouer à notre IA que des couleurs qui sont adjacentes à sa zone.
\subsection{Question 12}
    L'algorithme du glouton prévoyant repose sur deux parcours du monde avec la fonction \texttt{explore}, en testant toutes les combinaisons de 2 couleurs possibles jouées par le joueur (en ne testant pas les cas où le joueur joue deux fois de suite la même couleur). Le premier parcours se fait comme celui de l'algorithme glouton. Le second, en revanche, se fait différemment car on doit explorer les cases qui sont adjacentes aux cases qui appartiendraient au joueur s'il avait joué la première couleur testée. Ainsi, on ajoute l'argument \texttt{is\_second\_turn} à \texttt{explore}. Si celui-ci est différent de 0, alors le parcours se fera en sachant quelles cases ont déja été jouées lors du premier parcours, et ce qu'elles contiennent grâce aux cases de \texttt{explored} qui sont de type \texttt{Cell\_status}. Il a fallu modifier la fonction \texttt{explore} pour qu'elle prenne en argument un pointeur vers le tableau \texttt{explored}, car celui-ci est modifié entre les deux parcours. 
    Pour ce qui est de la complexité, on fait 42 tests composés de 2 parcours. Pour chacun de ses tests, on crée un nouveau tableau de taille $m^2$ si m est la largeur du monde, puis on appelle \texttt{explore} deux fois. Cette fonction utilise \texttt{update\_cell} et \texttt{must\_be\_explored} qui sont en $O(1)$ et se rappelle possiblement elle-même quatre fois. Or, l'utilisation du tableau \texttt{explored} nous assure que chaque case sera explorée au plus une fois par parcours. Ainsi, explored est appelée au maximum $m^2$ fois. La complexité de notre algorithme est donc en $O(m^2)$. Si on devait calculer pour les n prochains coups, il faudrait alors faire n parcours pour un test de combinaisons de couleurs. Il faudrait par contre tester $7*6^{(n-1)}$ combinaisons. On pourrait s'en sortir avec toujours un tableau \texttt{explored} et en modifiant l'argument \texttt{is\_second\_turn} par un argument qui nous dirait le nombre de parcours déja effectué. S'il vaut n, on arrête les parcours, sinon, on continue. La complexité de cet algorithme serait alors en $O({6^n}*n*m^2)$.
\section{Synthèse}
	L'implémentation du jeu des 7 couleurs, jeu pourtant relativement simple aux premiers abords, s'est révélée être bien plus compliquée qu'attendu. Au travers de ce projet, nous avons pu expérimenter avec la versatilité et la puissance du C. Ces deux aspects du langage se sont beaucoup manifestés dans la gestion de la mémoire, problématique clé qui a eu une énorme influence sur la structure du programme. L'utilisation de la fonction \texttt{malloc} était une chose nouvelle pour nous, et malgré son usage extensif tout au cours du programme, nous avons finalement eu peu de problèmes de "double free" et aucune fuite mémoire (d'après Valgrind).
	
	Toutefois, certaines idées se sont trouvées être plus complexe à implémenter. Par exemple, nous souhaitions à l'origine stocker dans une structure de donnée les coordonnées des cases qui forment le périmètre de la zone des joueurs. Cette structure aurait été mise à jour à chaque tour, et nous aurait permis d'effectuer \texttt{world_update} encore plus efficacement. Elle aurait également servi pour la stratégie hégémonique. Cependant, nous avons réalisé après son implémentation dans \texttt{utils.c} qu'elle pouvait contenir des doublons, et un parcours linéaire pour les retirer annihilait notre espoir d'efficacité. Cette structure a été cependant réutilisée dans d'autre contexte où les doublons ne sont pas un problème.

\section{Bibliographie}

- https://cboard.cprogramming.com/c-programming/123409-making-2d-array-matrix-struct.html

- https://stackoverflow.com/questions/1052818/create-a-pointer-to-two-dimensional-array

\end{document}
