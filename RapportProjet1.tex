\documentclass{article}
\usepackage{courier}
\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}

\title{Les 7 merveilles du monde des 7 couleurs}
\date{15 Octobre 2019}
\author{Antoine Geimer et Pierre Bourse}
\begin{document}
\maketitle

\section{Introduction}
    \quad Le jeu des 7 couleurs (aussi connu sous le nom \enquote{The 7 colors}) est un jeu développé par Gamos Ltd. et publié par Infogrames Europe SA, dans lequel deux joueurs s'affrontent dans le but d'agrandir sa zone, afin de dépasser celle de l'autre joueur en superficie. À travers ce projet, nous allons coder une version similaire mais simplifiée de ce jeu, en utilisant le langage C.
\section{Questions}
\subsection{Question 1}
    Nous avons tout d'abord changé l'implémentation proposée pour travailler avec un tableau en deux dimensions plutôt qu'un tableau en une seule dimension. Cela nous paraissait plus logique sémantiquement, car plus proche de la grille que cela représentait. Lors de la suite du projet, nous avons choisi de l'implémenter en utilisant la fonction \texttt{malloc} car cela simplifiait les appels de ce tableau dans les fonctions suivantes. Pour générer le terrain de jeu, nous avons alors créé la fonction \texttt{init\_board} qui crée un tableau de tableaux de caractères représentant le monde, et qui le remplit avec un caractère aléatoire parmi ceux disponibles, qui ont la particularité d'avoir un code ASCII entre 65 et 71. Ainsi, il suffit pour générer un caractère aléatoire de génerer un entier entre 65 et 71, ce que nous avons fait. Ensuite, il faut remplacer les cases en haut à droite et en bas à gauche par le symbole du joueur correspondant.
\subsection{Question 2}
    Pour cela, nous avons suivi exactement la méthode indiquée dans le sujet du projet, à travers la fonction \texttt{world\_update}. Pour vérifier qu'elle fait ce qu'on veut, il faut créer une fonction capable d'afficher le monde, puis afficher dans l'ordre dans le terminal le monde généré aléatoirement, le monde une fois \texttt{world\_update} appelée pour une certaine couleur et un certain joueur, puis après que la même fonction a été appelée pour une autre couleur et l'autre joueur. Si n est la longueur du mode, le nombre de parcours dans le pire des cas est borné par $n^2$ car on ne peut faire au maximum qu'un parcours par case modifiée. De plus, il existe une configuration dans laquelle le nombre de parcours est en $O(n^2)$ : lorsque le monde est une alternance de lignes de A et de lignes de B, avec un A seulement sur chaque ligne de B. le nombre de parcours dans le pire des cas est alors un $O(n^2)$.
\subsection{Question 3}
    Nous avons remplacé \texttt{world\_update} par la fonction \texttt{world\_update2}, qui fait beaucoup moins de parcours. Celle-ci utilise un tableau \texttt{explored} et une fonction \texttt{update} qui va faire un parcours du monde en commençant par la case de départ du joueur qui est en train de jouer. Le parcours va se faire sur toutes les cases du joueur et toutes les cases à modofier, en les modifiant. Le tableau \texttt{explored} nous permet de garder une trace des cases qui ont déja été explorées, pour ne pas les explorer une deuxième fois. Nous avons implémenté cette fonction après les fonctions nous permettant de jouer . Ainsi, il nous a suffit de jouer pour vérifier si la fonction fonctionnait.
\subsection{Question 4}
    Pour faire jouer deux humains entre eux, nous avons d'abord créé une structure \texttt{Game} qui contient toutes les informations nécessaires au déroulement de la partie. Nous générons alors au début d'une partie un pointeur vers un \texttt{Game} que nous passerons en argument de toutes les fonctions principales. La fonction \texttt{play\_turn}, qui gère le déroulement d'un tour, est alors appelée (pour l'instant) à l'infini, en alternant de joueur à chaque tour. Pour l'instant, les parties sont donc limitées car on ne peut avoir de vainqueurs si le jeu ne se termine jamais. De plus, il n'existe pas de mode 1 joueur avec une intelligence artificielle, et le fait que les couleurs soient remplacées par des caractères rend le jeu compliqué à lire et à comprendre. Il a également fallu ajouter des garde-fous pour éviter que le joueur entre une couleur inexistante ou le symbole de son adversaire.
\subsection{Question 5}
    On peut déclarer un joueur victorieux s'il possède plus de 50\% du monde, car alors, le second joueur ne pourra jamais le dépasser. Il suffit alors de modifier le taux d'occupation du monde pour chaque joueur à chaque fois qu'il joue, de l'afficher si on le souhaite, et de déclarer un joueur vainqueur en arrêtant la partie dès qu'un joueur dépasse 50\% d'occupation du terrain.
\subsection{Question 6}
    Nous avons créé un fichier annexe regroupant les différentes stratégies possibles pour l'IA. De plus, un membre a été ajouté dans le \texttt{Game} afin de modéliser le mode de jeu. Celui-ci est pour l'instant utilisé pour savoir si on joue en mode \enquote{joueur contre joueur} ou \enquote{IA contre joueur} en choisissant l'IA ou Pour ce premier cas de figure, il suffit simplement de générer un entier aléatoire entre 65 et 71 correspondant au code ASCII d'un caractère et de modifier le monde comme si le joueur adverse avait joué ce caractère.
\subsection{Question 7}
    On procède de la même façon que pour l'IA complétement aléatoire, mais le caractère choisi par l'IA sera renvoyé par la fonction \texttt{semi\_random\_strategy} qui prend un pointeur vers le \texttt{Game} en argument. Le programme initialise d'abord un tableau de 7 fois 0 et va parcourir le monde 1 fois en regardant pour chaque case si elle est adjacente au territoire du joueur actuel. Si elle l'est, on passe la case du tableau correspondant au caractère de la case à 1 (A correspond à la case d'indice 0, B à celle d'indice 1, etc.). Ainsi, le tableau contient un 1 dans la case i si et seulement si le caractère correspondant est adjacent au territoire du joueur. Il suffit alors de compter le nombre n de 1, de choisir un nombre aléatoire r entre 1 et n et de prendre le caractère correspondant à la $r^e$ occurence d'un 1 dans le tableau.
\subsection{Question 8}
    Pour notre \texttt{greedy\_strategy}, nous regardons, pour chaque couleur choisie par le joueur en cours, le score que le joueur gagnerait s'il choisissait cette couleur. Pour cela, nous faisons un parcours du monde par couleur. Ce parcours se fait avec la fonction \texttt{explore}. Ce parcours démarre sur la case de départ du joueur dont c'est le tour, et va récursivement s'appeler sur toutes les cases adjacentes si elles sont de la couleur du joueur ou de la couleur testée, en ajoutant 1 au score potentiel si la case visitée est de la couleur testée. Pour que ce parcours se termine, un pointeur vers un tableau \texttt{explored} est utilisé. Celui-ci est initialisé comme ne contenant que des cases \enquote{\texttt{UNEXPLORED}}, symbolise le monde et est mis à jour à chaque appel de \texttt{explore} pour qu'on n'explore pas 2 fois la même case. Une fois que les 7 parcours sont terminés, \texttt{greedy\_strategy} renvoie le caractère qui maximise le score gagné lors du parcours par \texttt{explore}.
\subsection{Question 9}
    Pour faire s'affronter deux IA entre elles, nous avons ajouté un mode de jeu \enquote{IA contre IA}. Pour que le combat soit vraiment équitable, il faut que le terrain soit symétrique. Une symétrie centrale ou une symétrie axiale par rapport à la diagonale qui va du haut à gauche au bas à droite créent un terrain équitable car chaque joueur a accès exactement aux mêmes caractères s'ils jouent le même coup. Nous avons opté pour la symétrie axiale, que nous avons donc implémentée dans la fonction \texttt{init\_board}.
\subsection{Question 10}
    Pour faire s'affronter deux IA entre elles sur plusieurs parties, nous avons implémenté une fonction \texttt{run\_n\_times} qui permet de simuler n parties sans afficher le monde à chaque étape, et d'afficher le nombre de parties gagnées par chacun des joueurs. Par souci d'équité, nous faisons en sorte que le premier joueur alterne entre les deux qui s'affrontent. Le joueur artificiel glouton a beaucoup plus de victoires. Il en a parfois 99 mais très souvent 100 sur 100 parties.
\subsection{Question 11}
    Pour le joueur hégémonique, nous avons réutilisé la fonction \texttt{explore} que nous avons modifiée en lui ajoutant un argument \texttt{is\_perimeter\_based}. Si celui-ci ne vaut pas 0, alors le parcours ne se fera pas de la même façon, et comptera le nombre de cases adjacentes à la zone du joueur (le périmètre), s'il joue une certaine couleur. Ainsi, l'algorithme définissant la stratégie de l'IA hégémonique consiste en un parcours avec explored pour chaque couleur , dans le but de sélectionner la couleur qui maximisera le périmètre du joueur après qu'il ait joué cette couleur. Avec cet algorithme, nous avions un problème : après un moment, toutes les couleurs qui faisaient gagner des cases au joueur hégémonique lui faisaient perdre en périmètre. Il choisissait donc de jouer une couleur qui ne lui faisait pas gagner de cases, et cela à l'infini. Ainsi, nous avons réglé ce problème en réutilisant les fonctions utilisées par \texttt{semi\_random\_strategy} afin de ne faire jouer à notre IA que des couleurs qui sont adjacentes à sa zone.
\subsection{Question 12}
    L'algorithme du glouton prévoyant repose sur deux parcours du monde avec la fonction \texttt{explore}, en testant toutes les combinaisons de 2 couleurs possibles jouées par le joueur (en ne testant pas les cas où le joueur joue deux fois de suite la même couleur). Le premier parcours se fait comme celui de l'algorithme glouton. Le second, en revanche, se fait différemment car on doit explorer les cases qui sont adjacentes aux cases qui appartiendraient au joueur s'il avait joué la première couleur testée. Ainsi, on ajoute l'argument \texttt{is\_second\_turn} à \texttt{explore}. Si celui-ci est différent de 0, alors le parcours se fera en sachant quelles cases ont déja été jouées lors du premier parcours, et ce qu'elles contiennent grâce aux cases de \texttt{explored} qui sont de type \texttt{Cell\_status}. Il a fallu modifier la fonction \texttt{explore} pour qu'elle prenne en argument un pointeur vers le tableau \texttt{explored}, car celui-ci est modifié entre les deux parcours. Au niveau de la complexité, on fait 42 tests composés de 2 parcours. Pour chacun de ses tests, on crée un nouveau tableau de taille $m^2$ si m est la largeur du monde, puis on appelle \texttt{explore} deux fois. Cette fonction utilise \texttt{update\_cell} et \texttt{must\_be\_explored} qui sont en $O(1)$ et se rappelle possiblement elle-même quatre fois. Or, l'utilisation du tableau \texttt{explored} nous assure que chaque case sera explorée au plus une fois par parcours. Ainsi, explored est appelée au maximum $m^2$ fois. La complexité de notre algorithme est donc en $O(m^2)$. Si on devait calculer pour les n prochains coups, il faudrait alors faire n parcours pour un test de combinaisons de couleurs. Il faudrait par contre tester $7*6^{(n-1)}$ combinaisons. On pourrait s'en sortir avec toujours un tableau \texttt{explored} et en modifiant l'argument \texttt{is\_second\_turn} par un argument qui nous dirait le nombre de parcours déja effectué. S'il vaut n, on arrête les parcours, sinon, on continue. La complexité de cet algorithme serait alors en $O({6^n}*n*m^2)$.
\section{Synthèse}


\section{Bibliographie}

- https://cboard.cprogramming.com/c-programming/123409-making-2d-array-matrix-struct.html

- https://stackoverflow.com/questions/1052818/create-a-pointer-to-two-dimensional-array

\end{document}
